Strings : 
les strings on peut les declarer a l'aide de 2 (") ou bien 3 (") 
concaténation a l'aide de "+"
on peut utiliser des variables dans des string(pour complété une string dynamique qui change suivant la var)
en utilisant la fonction format() qui prend en paramettre les var et leur valeur

"/" nous donne le resultat avec la virgule "//" nous donne le resultat sans virgule
pour dir si c egale ou nan on peut utiliser "is" ou "is not"

pour convertir une string a un iunteger  on utilise la fonction 'int()' et pour les floats on utilise 'float()'   
on peut multiplier les strings genre "test" * 10
    STRINGS
        dans les string il est preferer d'utiliser les (") car si on veut utiliser l'apostroph on aura pas besoin de faire l'anti slache 
        si on veut ecrir des string en 2 ligne ou plus on utilise """ some text """  si on on peut utiliser le \n pour sauter la ligne  
    LISTS
        on crée les tableau avec [ ]  
        append() : ajoute un element a la liste (au dernier)
        pop(): supprimer le dernier element de la liste  
        si on veut acceder au dernier element de la list on utilise nom_list[-1]  (c l'index numero -1)
        pour modifier les valeur de la liste on peut utiliser "List-Comprehension"
                syntax :  nvll_liste = [element for element in list ] genre on dit pour tout element dans la liste list alors donne nous element 
                si on veut dir le double alors c = [element * 2 for element in list]
                on peut faire une list-Comprehension avec "if" en ajoutant la condition a la fin de la list-Comprehension
        pour copier une liste a une nouvelle var on utilise var = list_name[:] on peut aussi determiner le debut et la fin (fin n'est pas inclue) 
            si on specifie pas le debut alors c 0
            cela MARCHE AUSSI POUR LES TUPLES   
            si on a une list de Dictionaries et on fait une copie de cette liste et on modifie les dictionnaries de la copie alors ceux de l'original aussi seront modifier 
                car la list contient juste les reference de ces dictionnaries 
        les list support le unpacking mais il faut donner autant de var que le nombre d'element du tableau
    FONCTIONS
        pour declarer une fonction on utilise : def nom_de_la_fonction() : 
        il faut laisse un vide a gauche pour specifier qu'on est encore dans la fonction car ya pas de {} pour declarer le debut et la fin de la fonction
        de preference il faut avoir 2 ligne entre les fonctions 
        on peut passer des argument par default au fonction dont on aura le choix  de le passer ou pas  lors de l'utilisation de  la focntion 
        on peut suitcher entre les positions des arguments de la fonction mais en presisant le nom des arguments et leur donner les valeur qu'on veut (KEYWORD ARGUMENTS)
        pour lir des string depuis le clavier on utilise la fonction " var_name = input("enter your text: ") "
            la fonction input lie que du texte si on veut lire des nombre ou boolean il faut le convertir 
        si on declare une var globale et on lui donne une valeur puis on réutilise dans une fonction alors kan on sort de la fonction sa valeur restera la valeur de la variable globale (la valeur original)
            si on veut modifier la var globale on declare que c la var global en utilisant  "global var_name" puis on l'utilise  

si on veut faire un commentaire on utilise "#"  pour commenter toute la ligne 
et si on veut juste ecrire un mot de commentaire dans la ligne on utilise """le commentaire """ et cela nous aide a bien comprendre le code
et pour rendre le code bien claire on peut definir pour chaque fonction les arguments et leurs signification

on peut ecrire les ligne de code qui sont long en plusieurs ligne de code pour avoir a clean code et visible 


    LOOPS  
        on utilise for dans les list pour repeter un code pour chaque case de la list  
        pour (avant qu'elle finisse)  quiter la boucle on utilise "break"
        et pour sauter une itteration on utilise continue
        dans les boucle on peu utilise "else" genre kan la condition de la boucle ne sera valider ou la boucle est terminer  alors ce block doit s'executer la mm utilisation que if-else 
        dans la boucle for pour avoir l'indexe de la boucle (genre le i de la boucle for dans js ) on utilise la fonction range()
            alors on utilise "for i in range(longeur_de_la_boucle): 
            range peut avoir 2 argument : le debut et la fin de la boucle 
            comme elle peut avoir 3 argument : le debut , la fin et le pas(the step)
        pour la boucle for on peut utiliser enumerate()  et nous retourne un tuple(valeur, son_indexe) donc pour l(itterateur on peut utiliser un tuple)

    IF 
        pour exprimer" else if " on utilise "elif" 
        si on utilise plusieurs elif alors on utilise un seul else a la fin 

l'operatuer "is" est presque comme l'operatuer "== " , et kan il ya 2 var qui porte la mm valeur l'operateur "==" nous donne  true  et "is" nous donne false 
    "is" compare les reference des var et "==" compare les valeurs
is verifie si vraiment sont les mm objet dans la memoire (genre pour donner vrai il faut compearer la mm var avec elle mm )
et l'operateur "in" nous donne si une valeur est dans une liste ou un tab 
l'operateur "not" nous la negation d'une expression like "2 not in tab "

    ya pas de swith in Python 

Structure de Donnée complexe
    Set 
        on peut le modifier mais les elements ne sont pas ordonnés et on peut pas avoir des données dupliqués , on peut avoir un ou plsr type de données
        on les crée en utilisant les {} ou avec "set([infos..])
    Tuple 
        on peut pas les modifier , les elemnts sont ordonnés et les dupliqués sont accépter 
        en les crée en utilisant les ()
        pour extracter les donnée des tupes ==> var_1, var_2= tuple_var ; alors le premiere element est dans la var_1 et le 2eme element est dans la var_2 
    Dictionary 
        il est similaire au Js Object avec des key-value paires
        on peut pas le changer et les element ne sont pas ordonnés pas de dupliqués pour les field_name , on peut trouver un mix de donnée dedant 
        on le crée comme on crée le JS Object
        kan on fait un for dans un Dictionary alors si on veut accéder au elements : dict_name[key] where key est un des fields
        on peut fair un dict-Comprehension et cela par la mm valeur de list-Comprehension mais en utiliser 2 paire key:value
        le unpacking nous donne les keys et n'ont pas les valeurs
    